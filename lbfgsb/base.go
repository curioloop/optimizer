// Copyright ©2025 curioloop. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package lbfgsb

import "syscall"

const (
	zero  = 0.0
	one   = 1.0
	two   = 2.0
	three = 3.0
)

type iterTask int8

const (
	iterLoop iterTask = 0
	iterConv iterTask = 1 << (4 + iota)
	iterStop
)

const (
	ConvGradProgNorm = iterConv | (1 + iota)
	ConvEnoughAccuracy
	StopAbnormalSearch = iterStop | (1 + iota)
	HaltEvalPanic
	OverIterLimit
	OverEvalLimit
	OverTimeLimit
	OverGradThresh
)

type errInfo int

const (
	ok                    errInfo = 0
	warnRestartLoop       errInfo = 1
	warnTooManySearch     errInfo = 2
	errNotPosDef1stK      errInfo = -1
	errNotPosDef2ndK      errInfo = -2
	errNotPosDefT         errInfo = -3
	errDerivative         errInfo = -4
	errSingularTriangular errInfo = -5
	errLineSearchFailed   errInfo = -6
	errLineSearchTol      errInfo = -7
)

type iterLoc struct {
	x []float64
	f float64
	g []float64
}

func (l *iterLoc) save(x []float64, f *float64, g []float64) {
	copy(x, l.x)
	*f = l.f
	copy(g, l.g)
}

func (l *iterLoc) load(x []float64, f float64, g []float64) {
	copy(l.x, x)
	l.f = f
	copy(l.g, g)
}

type bndHint int

const (
	bndNo bndHint = iota
	bndLow
	bndBoth
	bndUp
)

type varWhere int8

const (
	// varUnbound at i means xᵢ is always free (no bounds on it)
	varUnbound varWhere = iota - 1
	// varFree at i means xᵢ is free and has bounds
	varFree
	// varAtLB at i means xᵢ is fixed at lᵢ, and uᵢ ≠ lᵢ
	varAtLB
	// varAtUB at i means xᵢ is fixed at uᵢ, and uᵢ ≠ lᵢ
	varAtUB
	// varFixed at i means xᵢ is always fixed (uᵢ=xᵢ=lᵢ)
	varFixed
	// varNotMove at i means xᵢ is free and has bounds and not move
	varNotMove varWhere = -3
)

type loopTimer struct {
	time int64
}

func (t *loopTimer) reset() {
	t.time = t.now()
}

func (t *loopTimer) elapsed() int64 {
	return t.now() - t.time
}

func (t *loopTimer) now() int64 {
	var usage syscall.Rusage
	if err := syscall.Getrusage(syscall.RUSAGE_SELF, &usage); err == nil {
		return usage.Utime.Nano() + usage.Stime.Nano()
	}
	return -1
}

type iterSpec struct {
	// the dimension of the problem.
	n int
	// the maximum number of variable metric corrections used to define the limited memory matrix.
	m int
	// the machine precision generated by the code.
	epsilon float64
	eval    Evaluation
	stop    Termination
	bounds  []Bound
	logger  Logger
	search  *SearchTol
}

type iterBFGS struct {
	// indicate if the L-BFGS matrix is updated or not
	updated bool
	// the total number of BFGS updates prior the current iteration;
	updates int
	// the actual number of variable metric corrections stored so far.
	col int // 0 ≤ col ≤ m
	// the location of the first and last s-vector (or y-vector) in S (or Y).
	head, tail int
	// the scaling factor specifying B₀ = θI
	theta float64
}

type iterCtx struct {

	// the total number of intervals (quadratic segments) explored in searching for the GCP.
	totalSegGCP int
	// the total number of skipped BFGS updates before the current iteration;
	totalSkipBFGS int
	// the total number of function and gradient evaluations;
	totalEval int
	// the number of current iteration;
	iter int
	// the number of intervals (quadratic segments) explored in searching for the GCP.
	seg int

	// word specifies the status of the subspace solution.
	// if word = 0  then the subspace 𝚊𝚛𝚐𝚖𝚒𝚗 is within the box;
	// if word = 1  then the subspace 𝚊𝚛𝚐𝚖𝚒𝚗 is beyond the box;
	word int
	// the number of free variables in the current iteration;
	free int
	// the number of active constraints in the current iteration;
	active int
	// n + 1 - leave = the number of variables leaving the set of active constraints in the current iteration;
	leave int
	// the number of variables entering the set of active constraints in the current iteration.
	enter int

	projInitX   bool // the initial X has been replaced by its projection in the feasible set
	constrained bool // the problem is constrained
	boxed       bool // each variable has upper and lower bounds

	fOld   float64 // f(x) in the previous iteration
	sbgNrm float64 // the infinity norm of the projected gradient
	dSqrt  float64 // the square of the 2-norm of the line search direction vector
	dNorm  float64 // 2-norm of the line search direction vector

	iterTime
	iterBFGS
	iterWork
	searchWork
}

func (c *iterBFGS) reset() {
	c.col = 0
	c.head = 0
	c.tail = 0
	c.theta = one
	c.updates = 0
	c.updated = false
}

func (c *iterCtx) clear() {

	c.reset()
	c.word = solutionWithinBox
	c.free = 0
	c.active = 0
	c.leave = 0
	c.enter = 0

	c.fOld = zero
	c.sbgNrm = zero
	c.dSqrt = zero
	c.dNorm = zero

	c.gd = zero
	c.stp = zero
	c.gdOld = zero
	c.numEval = 0
	c.numBack = 0

	c.iter = 0
	c.seg = 0
	c.totalEval = 0
	c.totalSegGCP = 0

	c.gcpSearchTime = 0
	c.minSubspaceTime = 0
	c.lineSearchTime = 0
}

type iterWork struct {
	// stores S = s₁, s₂, ···, sₘ
	ws []float64 // n × m
	// stores Y = y₁, y₂, ···, yₘ
	wy []float64 // n × m
	// stores SᵀY = (sᵀy)₁, (sᵀy)₂, ···, (sᵀy)ₘ
	sy []float64 // m × m
	// stores SᵀS = (sᵀs)₁, (sᵀs)₂, ···, (sᵀs)ₘ
	ss []float64 // m × m

	// stores the Cholesky factorization of (θSᵀS+LD⁻¹Lᵀ) = JJᵀ
	wt []float64 // m × m
	// stores the LELᵀ factorization of
	//   [ -D-YᵀZZᵀY/θ   Laᵀ-Rzᵀ ]
	//   [ La-Rz         θSᵀAAᵀS ]
	wn []float64 // 2m × 2m = 4 × m² (4 matrices)
	// store the lower triangular part of
	//   [ YᵀZZᵀY   Laᵀ+Rzᵀ]
	//   [ La+Rz    SᵀAAᵀS ]
	snd []float64 // 2m × 2m = 4 × m² (4 matrices)

	// store the Cauchy point and the Newton point
	z []float64 // n
	r []float64 // n
	d []float64 // n
	t []float64 // n
	// safeguard the projected Newton direction
	xp []float64 // n
	// shared temporary workspace
	wa []float64 // 8 × m

	// In subroutine cauchy
	// - index[0] record the index of free variables based and then passed on to subroutine optimalDirection with this information.
	// - index[1] store the order of breakpoints.
	// In subroutine freeVar
	// - index[0] store the free and fixed variables at the Generalized Cauchy Point (GCP).
	// - index[1] record whether variables entering or leaving the free set, and then passed on to subroutine formK with this information.
	index [2][]int // n
	// In subroutine cauchy, record the status of the vector x for GCP computation.
	where []varWhere
}

func (w *iterWork) init(n, m int) {
	w.ws = make([]float64, m*n)
	w.wy = make([]float64, m*n)
	w.sy = make([]float64, m*m)
	w.ss = make([]float64, m*m)
	w.wt = make([]float64, m*m)
	w.wn = make([]float64, 4*m*m)
	w.snd = make([]float64, 4*m*m)
	w.z = make([]float64, n)
	w.r = make([]float64, n)
	w.d = make([]float64, n)
	w.t = make([]float64, n)
	w.xp = make([]float64, n)
	w.wa = make([]float64, 8*m)
	w.index[0] = make([]int, n)
	w.index[1] = make([]int, n)
	w.where = make([]varWhere, n)
}

type iterTime struct {
	shared          loopTimer
	global          loopTimer
	gcpSearchTime   int64 // the accumulated time spent on searching for Cauchy points
	minSubspaceTime int64 // the accumulated time spent on subspace minimization
	lineSearchTime  int64 // the accumulated time spent on line-search
}

type searchWork struct {
	numEval int     // the number of function value or gradient evaluations in the current iteration
	numBack int     // the number of backtracking search in the current iteration
	gd      float64 // the slope of the line search function at the current point of line search
	gdOld   float64 // the slope of the line search function at the starting point of the line search
	stp     float64 // the relative step length in the line search
	task    SearchTask
	ctx     SearchCtx
	tol     SearchTol
}
